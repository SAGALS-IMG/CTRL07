unit Unit_CT;

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,
  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, VclTee.TeeGDIPlus, Vcl.Buttons,
  Vcl.ExtCtrls, VCLTee.TeEngine, VCLTee.Series, Vcl.StdCtrls, Vcl.ComCtrls,
  VCLTee.TeeProcs, VCLTee.Chart, MMSystem, Unit_PW, Math, IniFiles ;

type
  TForm_CT = class(TForm)
    SB: TStatusBar;
    Chart1: TChart;
    GroupBox2: TGroupBox;
    BB_ABS_CT_ST: TBitBtn;
    BB_BS_CT_STOP: TBitBtn;
    CB_BK: TCheckBox;
    GroupBox5: TGroupBox;
    BB_FSCT_Start: TBitBtn;
    BB_Stop2: TBitBtn;
    CB_BK2: TCheckBox;
    Series1: TLineSeries;
    SaveDialog1: TSaveDialog;
    Memo: TRichEdit;
    BB_FS_Test: TBitBtn;
    BB_SavePh: TBitBtn;
    GroupBox1: TGroupBox;
    Label10: TLabel;
    CB_axis_abs_x: TComboBox;
    Edit_XZ_M: TEdit;
    Label23: TLabel;
    Edit_XZ_BK: TEdit;
    Edit_BKN: TEdit;
    Label11: TLabel;
    Edit_ABS_BK_EXPT: TEdit;
    Label1: TLabel;
    GroupBox3: TGroupBox;
    Label3: TLabel;
    CB_axis_abs_rot: TComboBox;
    Edit_R_ST: TEdit;
    Label4: TLabel;
    Edit_R_End: TEdit;
    Label8: TLabel;
    Edit_R_d: TEdit;
    Label5: TLabel;
    Edit_ABS_EXPT: TEdit;
    CB_Moni2: TCheckBox;
    CB_ExtC: TCheckBox;
    GroupBox4: TGroupBox;
    Label7: TLabel;
    Label9: TLabel;
    Label12: TLabel;
    Label17: TLabel;
    Label21: TLabel;
    Edit_Samp_Name: TEdit;
    Edit_Samp_Part: TEdit;
    Edit_Samp_Status: TEdit;
    Edit_Samp_Temp: TEdit;
    Sample_Memo: TRichEdit;
    Label22: TLabel;
    Label24: TLabel;
    Edit_ABS_BK_Int: TEdit;
    GroupBox6: TGroupBox;
    Label15: TLabel;
    CB_axis_ph_x: TComboBox;
    Edit_XZ_M2: TEdit;
    Label6: TLabel;
    Edit_XZ_BK2: TEdit;
    Label25: TLabel;
    Label26: TLabel;
    Edit_PH_BK_EXPT: TEdit;
    Label27: TLabel;
    Label28: TLabel;
    Edit_PH_BK_Int: TEdit;
    Edit_BKN2: TEdit;
    GroupBox7: TGroupBox;
    Label13: TLabel;
    CB_axis_ph_rot: TComboBox;
    Edit_R_End2: TEdit;
    Edit_R_d2: TEdit;
    Label14: TLabel;
    Edit_R_ST2: TEdit;
    Label2: TLabel;
    Edit_PH_EXPT: TEdit;
    Label16: TLabel;
    CheckBox1: TCheckBox;
    GroupBox8: TGroupBox;
    Label18: TLabel;
    CB_axis_ph_ph: TComboBox;
    Edit_FS_Orig: TEdit;
    Edit_FS_Start: TEdit;
    Label19: TLabel;
    Edit_FS_dP: TEdit;
    Label20: TLabel;
    Edit_FS_n: TEdit;
    Splitter1: TSplitter;
    CheckBox3: TCheckBox;
    CheckBox2: TCheckBox;
    procedure FormShow(Sender: TObject);
    procedure BB_ABS_CT_STClick(Sender: TObject);
    procedure FormCreate(Sender: TObject);
    procedure FormDestroy(Sender: TObject);
    procedure BB_FSCT_StartClick(Sender: TObject);
    procedure BB_SaveClick(Sender: TObject);
    procedure BB_FS_TestClick(Sender: TObject);
    procedure BB_SavePhClick(Sender: TObject);
    procedure CB_axis_abs_rotChange(Sender: TObject);
    procedure CB_axis_abs_xChange(Sender: TObject);
    procedure CB_axis_ph_phChange(Sender: TObject);
    procedure CB_axis_ph_rotChange(Sender: TObject);
    procedure CB_axis_ph_xChange(Sender: TObject);
  private
    { Private êÈåæ }
  public
    { Public êÈåæ }
  end;

var
  Form_CT: TForm_CT;

  CT_R_Ch, CT_X_Ch : byte;
  PCT_R_Ch, PCT_X_Ch, PCT_Ph_Ch : byte;

  ABS_BK0, ABS_BK1, ABS_Rot1, ABS_Rot2, ABS_dR, ABS_BKN :longint;
  PH_BK0, PH_BK1, PH_Rot1, PH_Rot2, PH_dR, PH_BKN, PH_PH0, PH_PH1,PH_dPH, PH_n: longint;

  IntData : array[0..2160,0..2560] of WORD;
  FSData : array[0..10,0..2160,0..2560] of WORD;
  PHData : array[0..2160,0..2560] of double;

  Go : boolean;
implementation

{$R *.dfm}

uses Unit_PM16C, Unit_Imager;

procedure TForm_CT.FormCreate(Sender: TObject);
var
  Ini: TIniFile;
begin
  Ini := TIniFile.Create( ChangeFileExt( Application.ExeName, '.INI' ) );
  try
    Top     := Ini.ReadInteger( 'Form_Img', 'Top', 100 );
    Left    := Ini.ReadInteger( 'Form_Img', 'Left', 100 );
    if Ini.ReadBool( 'Form_Img', 'InitMax', false ) then
      WindowState := wsMaximized
    else
      WindowState := wsNormal;

    Edit_XZ_M.Text :=  Ini.ReadString('CT','ABS_Xm','0');
    Edit_XZ_BK.Text := Ini.ReadString('CT','ABS_XBK','-20000');
    Edit_R_ST.Text :=  Ini.ReadString('CT','ABS_RST','0');
    Edit_R_End.Text := Ini.ReadString('CT','ABS_REND','189000');
    Edit_R_d.Text :=   Ini.ReadString('CT','ABS_dR','180');
    Edit_BKN.Text :=   Ini.ReadString('CT','ABS_N','100');
    CB_BK.Checked :=   Ini.ReadBool('CT','ABS_MesBK',true);

    Edit_XZ_M2.Text := Ini.ReadString('CT','PH_Xm','0');
    Edit_XZ_BK2.Text :=Ini.ReadString('CT','PH_XBK','-20000');
    Edit_R_ST2.Text := Ini.ReadString('CT','PH_RST','0');
    Edit_R_End2.Text :=Ini.ReadString('CT','PH_REND','189000');
    Edit_R_d2.Text :=  Ini.ReadString('CT','PH_dR','180');
    Edit_BKN2.Text :=  Ini.ReadString('CT','PH_N','100');
    CB_BK2.Checked :=  Ini.ReadBool('CT','PH_MesBK',true);

    Edit_FS_Orig.Text  :=Ini.ReadString('CT','FS_Orig','-1000');
    Edit_FS_Start.Text :=Ini.ReadString('CT','FS_ST','0');
    Edit_FS_dP.Text    :=Ini.ReadString('CT','FS_dP','2000');
    Edit_FS_n.Text     :=Ini.ReadString('CT','FS_ND','5');

    CT_R_Ch         := Ini.ReadInteger('CT','ABS_R_Ch',0);
    CT_X_ch         := Ini.ReadInteger('CT','ABS_X_Ch',0);

    PCT_R_Ch        := Ini.ReadInteger('CT','PH_R_Ch',0);
    PCT_X_Ch        := Ini.ReadInteger('CT','PH_X_Ch',0);
    PCT_PH_Ch       := Ini.ReadInteger('CT','FS_Ch',0);

  finally
    Ini.Free;
  end;
end;

procedure TForm_CT.FormDestroy(Sender: TObject);
var
  Ini: TIniFile;
begin

  Ini := TIniFile.Create( ChangeFileExt( Application.ExeName, '.INI' ) );
  try
    Ini.WriteInteger( 'Form_Img', 'Top', Top);
    Ini.WriteInteger( 'Form_Img', 'Left', Left);
    Ini.WriteBool( 'Form_Img', 'InitMax', WindowState = wsMaximized );

    Ini.WriteString('CT','ABS_Xm', Edit_XZ_M.Text);
    Ini.WriteString('CT','ABS_XBK',Edit_XZ_BK.Text);
    Ini.WriteString('CT','ABS_RST',Edit_R_ST.Text);
    Ini.WriteString('CT','ABS_REND',Edit_R_End.Text);
    Ini.WriteString('CT','ABS_dR',  Edit_R_d.Text);
    Ini.WriteString('CT','ABS_N',   Edit_BKN.Text);
    Ini.WriteBool('CT','ABS_MesBK', CB_BK.Checked);

    Ini.WriteString('CT','PH_Xm',  Edit_XZ_M2.Text);
    Ini.WriteString('CT','PH_XBK', Edit_XZ_BK2.Text);
    Ini.WriteString('CT','PH_RST', Edit_R_ST2.Text);
    Ini.WriteString('CT','PH_REND',Edit_R_End2.Text);
    Ini.WriteString('CT','PH_dR',  Edit_R_d2.Text);
    Ini.WriteString('CT','PH_N',   Edit_BKN2.Text);
    Ini.WriteBool('CT','PH_MesBK', CB_BK2.Checked);

    Ini.WriteString('CT','FS_Orig',Edit_FS_Orig.Text);
    Ini.WriteString('CT','FS_ST',  Edit_FS_Start.Text);
    Ini.WriteString('CT','FS_dP',  Edit_FS_dP.Text);
    Ini.WriteString('CT','FS_ND',  Edit_FS_n.Text);

    Ini.WriteInteger('CT','ABS_R_Ch',CB_axis_abs_rot.ItemIndex);
    Ini.WriteInteger('CT','ABS_X_Ch',CB_axis_abs_x.ItemIndex );

    Ini.WriteInteger('CT','PH_R_Ch', CB_axis_ph_rot.ItemIndex);
    Ini.WriteInteger('CT','PH_X_Ch', CB_axis_ph_x.ItemIndex  );
    Ini.WriteInteger('CT','FS_Ch',   CB_axis_ph_ph.ItemIndex );

  finally
    Ini.Free;
  end;
end;

procedure TForm_CT.FormShow(Sender: TObject);
var
  li:byte;
begin
  if Form_PM16C.CB_Connect.Checked then
  begin
    CB_axis_abs_rot.Items.Clear;
    CB_axis_abs_x.Items.Clear;
    CB_axis_ph_rot.Items.Clear;
    CB_axis_ph_x.Items.Clear;
    CB_axis_ph_ph.Items.Clear;

    for li:=0 to 15 do
    begin
      CB_axis_abs_rot.Items.Add(Form_PM16C.Motor[li].Axis_Name);
      CB_axis_abs_x.Items.Add(Form_PM16C.Motor[li].Axis_Name);
      CB_axis_ph_rot.Items.Add(Form_PM16C.Motor[li].Axis_Name);
      CB_axis_ph_x.Items.Add(Form_PM16C.Motor[li].Axis_Name);
      CB_axis_ph_ph.Items.Add(Form_PM16C.Motor[li].Axis_Name);
    end;

    CB_axis_abs_rot.ItemIndex := CT_R_Ch;
    CB_axis_abs_x.ItemIndex := CT_X_ch;

    CB_axis_ph_rot.ItemIndex := PCT_R_Ch;
    CB_axis_ph_x.ItemIndex := PCT_X_Ch;
    CB_axis_ph_ph.ItemIndex := PCT_PH_Ch;
  end;
end;

procedure TForm_CT.CB_axis_abs_rotChange(Sender: TObject);
begin
  CT_R_Ch := CB_axis_abs_rot.ItemIndex;
end;

procedure TForm_CT.CB_axis_abs_xChange(Sender: TObject);
begin
  CT_X_ch := CB_axis_abs_x.ItemIndex
end;

procedure TForm_CT.CB_axis_ph_phChange(Sender: TObject);
begin
  PCT_PH_Ch := CB_axis_ph_ph.ItemIndex;
end;

procedure TForm_CT.CB_axis_ph_rotChange(Sender: TObject);
begin
  PCT_R_Ch := CB_axis_ph_rot.ItemIndex;
end;

procedure TForm_CT.CB_axis_ph_xChange(Sender: TObject);
begin
  PCT_X_Ch := CB_axis_ph_x.ItemIndex;
end;

procedure TForm_CT.BB_ABS_CT_STClick(Sender: TObject);
var
  Rot, RST, REnd,dR,X0,XBK,BKN , AXR, AXX:longint;
  i,j,k,BufSize, ImgNo:longint;
  X1, X2, Z1, Z2 : longint;
  ImageSizeBytes, BufferSize : Int64;
  pBuf : pointer;
  TimeStart : Cardinal;
  TmpDbl : double;

  FS : TFileStream;
  lData : array[0..2560] of WORD;
  lExpT : longint;
begin
  if SaveDialog1.Execute then
  begin
    RST := StrToInt(Edit_R_St.Text);
    REnd := StrToInt(Edit_R_End.Text);
    dR := StrToInt(Edit_R_d.Text);
    X0 := StrToInt(Edit_XZ_M.Text);
    XBK := StrToInt(Edit_XZ_BK.Text);
    BKN := StrToInt(Edit_BKN.Text);
    AXR := Form_PM16C.Motor[CB_axis_abs_rot.ItemIndex].Mot_No;
    AXX := Form_PM16C.Motor[CB_axis_abs_x.ItemIndex].Mot_No;

    FS := TfileStream.Create(SaveDialog1.FileName,fmCreate);
    Go := true;

    Form_PM16C.Set_Remote;
    Form_PM16C.SetCh(0,AXR);
    Form_PM16C.SetCh(1,AXX);

    X1 := StrToInt(Img_Win.Edit_Left.Text);
    X2 := StrToInt(Img_Win.Edit_Right.Text);
    Z1 := StrToInt(Img_Win.Edit_Top.Text);
    Z2 := StrToInt(Img_Win.Edit_Bottom.Text);

    if CB_Moni2.Checked then
      Series1.Clear;

    if not(CB_ExtC.Checked) then
    begin
//      ImgNo := 0;
//      AT_GetInt(Hndl, 'ImageSizeBytes', @ImageSizeBytes);
//      BufferSize := ImageSizeBytes;
//      for i:=0 to NumberOfBuffers-1 do
//        AT_QueueBuffer(Hndl, AlignedBuffers[i], BufferSize);
//      Memo.Lines.Add('Set Mode: '+AT_SetEnumString(Hndl, 'CycleMode', 'Continuous').ToString);
//      Memo.Lines.Add('Set Trigger'+AT_SetEnumString(Hndl, 'TriggerMode', 'Software').ToString);
//      Memo.Lines.Add('Start'+AT_Command(Hndl,'AcquisitionStart').ToString);
    end;

    if CB_BK.Checked then
    begin
      Form_PM16C.MoveTo(AXX,XBK,true,true);

      for k:=0 to BKN-1 do
      begin
        if not(CB_ExtC.Checked) then
        begin
          TimeStart := timeGetTime;

//          AT_Command(Hndl,'SoftwareTrigger');
////          AT_WaitBuffer(Hndl, Addr(pBuf), Addr(BufSize), AT_INFINITE);
//
//          for j:=0 to PH-1 do
//            for i:=0 to PW+-1 do
//              IntData[j,i] := AlignedBuffers[ImgNo mod NumberOfBuffers]^[j*PW+i];
//
//          for j:=0 to PH-1 do
//            for i:=0 to PW+-1 do
//              ImgW.PData[j,i] := IntData[j,i];
//          if not(ImgW.Showing) then
//            ImgW.Show;
//          ImgW.Draw_Data(Sender);
//
//          for j:=0 to PH-1 do
//          begin
//            for i:=0 to PW-1 do
//              lData[i] := IntData[j,i];
//            FS.WriteBuffer(lData,PW*2);
//          end;
//
//          AT_QueueBuffer(Hndl, AlignedBuffers[ImgNo mod NumberOfBuffers], BufferSize);

          Inc(ImgNo);
        end
        else
        begin
          Form_PM16C.Pulse(3);
          Sleep(lExpT);
        end;

        SB.SimpleText := 'BK: '+(k+1).ToString+'/'+BKN.ToString+', Expose : '+ (timeGetTime - TimeStart).ToString;
        Application.ProcessMessages;
        if not(Go) then
        begin
//          Memo.Lines.Add('Stop: '+AT_Command(Hndl, 'AcquisitionStop').ToString);
//          if not(CB_ExtC.Checked) then
//            AT_Flush(Hndl);
          ShowMessage('Aborted');
          FS.Free;
          exit;
        end;

//        if CB_Moni2.Checked then
//        begin
//          TmpDbl := 0;
//          for j:=Z1 to Z2 do
//            for i:=X1 to X2 do
//              TmpDbl := TmpDbl + IntData[j,i];
//          TmpDbl := TmpDbl/((Z2-Z1+1)*(X2-X1+1));
//          Series1.AddY(TmpDbl);
//        end;
      end;
      Form_PM16C.MoveTo(AXX,X0,true,true);
    end;

    if not(Go) then exit;

    Rot:=RST;
    if dR>0 then
      Form_PM16C.MoveTo(AXR,Rot-200,true,true)
    else
      Form_PM16C.MoveTo(AXR,Rot+200,true,true);
    Form_PM16C.MoveTo(AXR,Rot,true,true);

    repeat
      if not(CB_ExtC.Checked) then
      begin
//        TimeStart := timeGetTime;
//        AT_Command(Hndl,'SoftwareTrigger');
//        AT_WaitBuffer(Hndl, Addr(pBuf), Addr(BufSize), AT_INFINITE);
//
//        for j:=0 to PH-1 do
//          for i:=0 to PW+-1 do
//            IntData[j,i] := AlignedBuffers[ImgNo mod NumberOfBuffers]^[j*PW+i];
//
//        for j:=0 to PH-1 do
//          for i:=0 to PW+-1 do
//            ImgW.PData[j,i] := IntData[j,i];
//        if not(ImgW.Showing) then
//          ImgW.Show;
//        ImgW.Draw_Data(Sender);
//
//        for j:=0 to PH-1 do
//        begin
//          for i:=0 to PW-1 do
//            lData[i] := IntData[j,i];
//          FS.WriteBuffer(lData,PW*2);
//        end;
//
//        AT_QueueBuffer(Hndl, AlignedBuffers[ImgNo mod NumberOfBuffers], BufferSize);
//
//        Inc(ImgNo);
      end
      else
      begin
        Form_PM16C.Pulse(3);
        Sleep(lExpT);
      end;

      Rot := Rot+dR;
      Form_PM16C.MoveTo(AXR,Rot,true,false);

      SB.SimpleText := Rot.ToString+'/'+REnd.ToString+', Expose : '+ (timeGetTime - TimeStart).ToString;
      Application.ProcessMessages;

      if not(Go) then
      begin
//        Memo.Lines.Add('Stop: '+AT_Command(Hndl, 'AcquisitionStop').ToString);
//        if not(CB_ExtC.Checked) then
//          AT_Flush(Hndl);
        ShowMessage('Aborted');
        FS.Free;
        exit;
      end;
//      if CB_Moni2.Checked then
//      begin
//        TmpDbl := 0;
//        for j:=Z1 to Z2 do
//          for i:=X1 to X2 do
//            TmpDbl := TmpDbl + IntData[j,i];
//        TmpDbl := TmpDbl/((Z2-Z1+1)*(X2-X1+1));
//        Series1.AddY(TmpDbl);
//      end;
    until ((Rot>=REnd) and (dR>0)) or ((Rot<=REnd) and (dR<0)) or not(go);

    if not(Go) then exit;

    if CB_BK.Checked then
    begin
      Form_PM16C.MoveTo(AXX,XBK,true,true);

      for k:=0 to BKN-1 do
      begin
        if not(CB_ExtC.Checked) then
        begin
//          TimeStart := timeGetTime;
//          AT_Command(Hndl,'SoftwareTrigger');
//          AT_WaitBuffer(Hndl, Addr(pBuf), Addr(BufSize), AT_INFINITE);
//
//          for j:=0 to PH-1 do
//            for i:=0 to PW+-1 do
//              IntData[j,i] := AlignedBuffers[ImgNo mod NumberOfBuffers]^[j*PW+i];
//
//          for j:=0 to PH-1 do
//            for i:=0 to PW+-1 do
//              ImgW.PData[j,i] := IntData[j,i];
//          if not(ImgW.Showing) then
//            ImgW.Show;
//          ImgW.Draw_Data(Sender);
//
//          for j:=0 to PH-1 do
//          begin
//            for i:=0 to PW-1 do
//              lData[i] := IntData[j,i];
//            FS.WriteBuffer(lData,PW*2);
//          end;
//
//          AT_QueueBuffer(Hndl, AlignedBuffers[ImgNo mod NumberOfBuffers], BufferSize);
//
//          Inc(ImgNo);
        end
        else
        begin
          Form_PM16C.Pulse(3);
          Sleep(lExpT);
        end;

        SB.SimpleText := 'BK: '+(k+1).ToString+'/'+BKN.ToString+', Expose : '+ (timeGetTime - TimeStart).ToString;
        Application.ProcessMessages;
        if not(Go) then
        begin
//          Memo.Lines.Add('Stop: '+AT_Command(Hndl, 'AcquisitionStop').ToString);
//          AT_Flush(Hndl);
//          ShowMessage('Aborted');
          FS.Free;
          exit;
        end;
//        if CB_Moni2.Checked then
//        begin
//          TmpDbl := 0;
//          for j:=Z1 to Z2 do
//            for i:=X1 to X2 do
//              TmpDbl := TmpDbl + IntData[j,i];
//          TmpDbl := TmpDbl/((Z2-Z1+1)*(X2-X1+1));
//          Series1.AddY(TmpDbl);
//        end;
      end;

      Form_PM16C.MoveTo(AXX,X0,true,true);
    end;
//    Memo.Lines.Add('Stop: '+AT_Command(Hndl, 'AcquisitionStop').ToString);
//    AT_Flush(Hndl);
    FS.Free;
    ShowMessage('Finished');
    Form_PM16C.SB_RefreshClick(Sender);
  end;
end;

procedure TForm_CT.BB_FSCT_StartClick(Sender: TObject);
var
  Rot, RST, REnd,dR,X0,XBK,BKN,lW:longint;
  PST,PN,POrig,dP:longint;
  i,j,k,kk,ret,BufSize, ImgNo:longint;
  ImageSizeBytes, BufferSize : Int64;
  pBuf : pointer;
  TimeStart : Cardinal;
  FS : TFileStream;
  AXR,AXX,AXP:byte;
  lData : array[0..2560] of WORD;
  X1, X2, Z1, Z2 : longint;
  TmpDbl : double;
begin
  if SaveDialog1.Execute then
  begin
    FS := TfileStream.Create(SaveDialog1.FileName,fmCreate);
    Go := true;

    RST := StrToInt(Edit_R_St2.Text);
    REnd := StrToInt(Edit_R_End2.Text);
    dR := StrToInt(Edit_R_d2.Text);
    X0 := StrToInt(Edit_XZ_M2.Text);
    XBK := StrToInt(Edit_XZ_BK2.Text);
    BKN := StrToInt(Edit_BKN2.Text);

    PST := StrToInt(Edit_FS_Start.Text);
    PN := StrToInt(Edit_FS_n.Text);
    POrig := StrToInt(Edit_FS_Orig.Text);
    dP := StrToInt(Edit_FS_dP.Text);

    AXR := Form_PM16C.Motor[CB_axis_ph_rot.ItemIndex].Mot_No;
    AXX := Form_PM16C.Motor[CB_axis_ph_x.ItemIndex].Mot_No;
    AXP := Form_PM16C.Motor[CB_axis_ph_ph.ItemIndex].Mot_No;

    X1 := StrToInt(Img_Win.Edit_Left.Text);
    X2 := StrToInt(Img_Win.Edit_Right.Text);
    Z1 := StrToInt(Img_Win.Edit_Top.Text);
    Z2 := StrToInt(Img_Win.Edit_Bottom.Text);

    Form_PM16C.Set_Remote;
    Form_PM16C.SetCh(0,AXP);
    Form_PM16C.SetCh(1,AXR);
    Form_PM16C.SetCh(2,AXX);

//    ImgNo := 0;
//    AT_GetInt(Hndl, 'ImageSizeBytes', @ImageSizeBytes);
//    BufferSize := ImageSizeBytes;
//    for i:=0 to NumberOfBuffers-1 do
//      AT_QueueBuffer(Hndl, AlignedBuffers[i], BufferSize);
//    Memo.Lines.Add('Set Mode: '+AT_SetEnumString(Hndl, 'CycleMode', 'Continuous').ToString);
//    Memo.Lines.Add('Set Trigger'+AT_SetEnumString(Hndl, 'TriggerMode', 'Software').ToString);
//    Memo.Lines.Add('Start'+AT_Command(Hndl,'AcquisitionStart').ToString);

    if CB_BK2.Checked then
    begin
      Form_PM16C.MoveTo(AXX,XBK,true,true);
      Series1.Clear;

      for k:=0 to BKN-1 do
      begin
        Form_PM16C.MoveTo(AXP,POrig,true,false);

        for kk:=0 to PN-1do
        begin
          TimeStart := timeGetTime;

          Form_PM16C.MoveTo(AXP,PST+dP*kk,true,false);

//          AT_Command(Hndl,'SoftwareTrigger');
//          AT_WaitBuffer(Hndl, Addr(pBuf), Addr(BufSize), AT_INFINITE);

          for j:=0 to PH-1 do
            for i:=0 to PW+-1 do
              IntData[j,i] := AlignedBuffers[ImgNo mod NumberOfBuffers]^[j*PW+i];

          for j:=0 to PH-1 do
            for i:=0 to PW+-1 do
              Img_Win.PData[j,i] := IntData[j,i];
          if not(Img_Win.Showing) then
            Img_Win.Show;
          Img_Win.Draw_Data(Sender);

          for j:=0 to PH-1 do
          begin
            for i:=0 to PW-1 do
              lData[i] := IntData[j,i];
            FS.WriteBuffer(lData,PW*2);
          end;

//          AT_QueueBuffer(Hndl, AlignedBuffers[ImgNo mod NumberOfBuffers], BufferSize);

          Inc(ImgNo);
          SB.SimpleText := 'BK: '+(k+1).ToString+'/'+BKN.ToString+' FS : '+kk.ToString+', Expose : '+ (timeGetTime - TimeStart).ToString;
          Application.ProcessMessages;

          if CB_Moni2.Checked then
          begin
            TmpDbl := 0;
            for j:=Z1 to Z2 do
              for i:=X1 to X2 do
                TmpDbl := TmpDbl + IntData[j,i];
            TmpDbl := TmpDbl/((Z2-Z1+1)*(X2-X1+1));
            Series1.AddXY(PST+dP*kk, TmpDbl);
          end;

          if not(Go) then
          begin
//            Memo.Lines.Add('Stop: '+AT_Command(Hndl, 'AcquisitionStop').ToString);
//            AT_Flush(Hndl);
            ShowMessage('Aborted');
            FS.Free;
            exit;
          end;

        end;
      end;
      Form_PM16C.MoveTo(AXX,X0,true,true);
    end;

    if not(Go) then exit;

    Rot:=RST;
    if dR>0 then
      Form_PM16C.MoveTo(AXR,Rot-200,true,true)
    else
      Form_PM16C.MoveTo(AXR,Rot+200,true,true);
    Form_PM16C.MoveTo(AXR,Rot,true,true);

    repeat
      Form_PM16C.MoveTo(AXP,POrig,true,false);
      Series1.Clear;

      for kk:=0 to PN-1do
      begin
        TimeStart := timeGetTime;

        Form_PM16C.MoveTo(AXP,PST+dP*kk,true,false);

//        AT_Command(Hndl,'SoftwareTrigger');
//        AT_WaitBuffer(Hndl, Addr(pBuf), Addr(BufSize), AT_INFINITE);

        for j:=0 to PH-1 do
          for i:=0 to PW+-1 do
            IntData[j,i] := AlignedBuffers[ImgNo mod NumberOfBuffers]^[j*PW+i];

        for j:=0 to PH-1 do
          for i:=0 to PW+-1 do
            Img_Win.PData[j,i] := IntData[j,i];
        if not( Img_Win.Showing) then
           Img_Win.Show;
        Img_Win.Draw_Data(Sender);

        for j:=0 to PH-1 do
        begin
          for i:=0 to PW-1 do
            lData[i] := IntData[j,i];
          FS.WriteBuffer(lData,PW*2);
        end;

//        AT_QueueBuffer(Hndl, AlignedBuffers[ImgNo mod NumberOfBuffers], BufferSize);

        Inc(ImgNo);
        SB.SimpleText := Rot.ToString+'/'+REnd.ToString+' FS : '+kk.ToString+', Expose : '+ (timeGetTime - TimeStart).ToString;
        Application.ProcessMessages;

        if CB_Moni2.Checked then
        begin
          TmpDbl := 0;
          for j:=Z1 to Z2 do
            for i:=X1 to X2 do
              TmpDbl := TmpDbl + IntData[j,i];
          TmpDbl := TmpDbl/((Z2-Z1+1)*(X2-X1+1));
          Series1.AddXY(PST+dP*kk, TmpDbl);
        end;

        if not(Go) then
        begin
//          Memo.Lines.Add('Stop: '+AT_Command(Hndl, 'AcquisitionStop').ToString);
//          AT_Flush(Hndl);
          ShowMessage('Aborted');
          FS.Free;
          exit;
        end;

      end;

      Rot := Rot+dR;
      Form_PM16C.MoveTo(AXR,Rot,true,false);
    until ((Rot>=REnd) and (dR>0)) or ((Rot<=REnd) and (dR<0)) or not(go);

    if not(Go) then exit;

    if CB_BK2.Checked then
    begin
      Form_PM16C.MoveTo(AXX,XBK,true,true);
      Series1.Clear;

      for k:=0 to BKN-1 do
      begin
        Form_PM16C.MoveTo(AXP,POrig,true,false);

        for kk:=0 to PN-1do
        begin
          TimeStart := timeGetTime;

          Form_PM16C.MoveTo(AXP,PST+dP*kk,true,false);

//          AT_Command(Hndl,'SoftwareTrigger');
//          AT_WaitBuffer(Hndl, Addr(pBuf), Addr(BufSize), AT_INFINITE);

          for j:=0 to PH-1 do
            for i:=0 to PW+-1 do
              IntData[j,i] := AlignedBuffers[ImgNo mod NumberOfBuffers]^[j*PW+i];

          for j:=0 to PH-1 do
            for i:=0 to PW+-1 do
              Img_Win.PData[j,i] := IntData[j,i];
          if not(Img_Win.Showing) then
            Img_Win.Show;
          Img_Win.Draw_Data(Sender);

          for j:=0 to PH-1 do
          begin
            for i:=0 to PW-1 do
              lData[i] := IntData[j,i];
            FS.WriteBuffer(lData,PW*2);
          end;

//          AT_QueueBuffer(Hndl, AlignedBuffers[ImgNo mod NumberOfBuffers], BufferSize);

          Inc(ImgNo);
          SB.SimpleText := 'BK: '+(k+1).ToString+'/'+BKN.ToString+' FS : '+kk.ToString+', Expose : '+ (timeGetTime - TimeStart).ToString;
          Application.ProcessMessages;

          if CB_Moni2.Checked then
          begin
            TmpDbl := 0;
            for j:=Z1 to Z2 do
              for i:=X1 to X2 do
                TmpDbl := TmpDbl + IntData[j,i];
            TmpDbl := TmpDbl/((Z2-Z1+1)*(X2-X1+1));
            Series1.AddXY(PST+dP*kk, TmpDbl);
          end;

          if not(Go) then
          begin
//            Memo.Lines.Add('Stop: '+AT_Command(Hndl, 'AcquisitionStop').ToString);
//            AT_Flush(Hndl);
            ShowMessage('Aborted');
            FS.Free;
            exit;
          end;

        end;
      end;
      Form_PM16C.MoveTo(AXX,X0,true,true);
    end;

//    Memo.Lines.Add('Stop: '+AT_Command(Hndl, 'AcquisitionStop').ToString);
//    AT_Flush(Hndl);
    FS.Free;
    ShowMessage('Finished');
  end;
end;

procedure TForm_CT.BB_FS_TestClick(Sender: TObject);
var
  lW:longint;
  PST,PN,POrig,dP,AXP:longint;
  i,j,kk,ret,BufSize, ImgNo:longint;
  ImageSizeBytes, BufferSize : Int64;
  pBuf : pointer;
  TimeStart : Cardinal;
  re,im:double;
  lData : array[0..2560] of WORD;
  MyCos,MySin : array[0..50] of double;
begin
  Go := true;

  PST := StrToInt(Edit_FS_Start.Text);
  PN := StrToInt(Edit_FS_n.Text);
  POrig := StrToInt(Edit_FS_Orig.Text);
  dP := StrToInt(Edit_FS_dP.Text);

  for i:=0 to PN-1 do
  begin
    MyCos[i] := Cos(i/PN*2*Pi);
    MySin[i] := Sin(i/PN*2*Pi);
  end;

  AXP := Motor[CB_axis_ph_ph.ItemIndex].Mot_No;
  Form_PM16C.Set_Remote;
  Form_PM16C.SetCh(0,AXP);

  ImgNo := 0;
//  AT_GetInt(Hndl, 'ImageSizeBytes', @ImageSizeBytes);
//  BufferSize := ImageSizeBytes;
//  for i:=0 to NumberOfBuffers-1 do
//    AT_QueueBuffer(Hndl, AlignedBuffers[i], BufferSize);
//  Memo.Lines.Add('Set Mode: '+AT_SetEnumString(Hndl, 'CycleMode', 'Continuous').ToString);
//  Memo.Lines.Add('Set Trigger'+AT_SetEnumString(Hndl, 'TriggerMode', 'Software').ToString);
//  Memo.Lines.Add('Start'+AT_Command(Hndl,'AcquisitionStart').ToString);

  Form_PM16C.MoveTo(AXP,POrig,true,true);

  for kk:=0 to PN-1do
  begin
    Form_PM16C.MoveTo(AXP,PST+dP*kk,true,true);

    TimeStart := timeGetTime;
//    AT_Command(Hndl,'SoftwareTrigger');
//    AT_WaitBuffer(Hndl, Addr(pBuf), Addr(BufSize), AT_INFINITE);

    for j:=0 to PH-1 do
      for i:=0 to PW+-1 do
        IntData[j,i] := AlignedBuffers[ImgNo mod NumberOfBuffers]^[j*PW+i];

    for j:=0 to PH-1 do
      for i:=0 to PW+-1 do
      begin
        Img_Win.PData[j,i] := IntData[j,i];
        FSData[kk,j,i] := IntData[j,i];
      end;
    if not(Img_Win.Showing) then
      Img_Win.Show;
    Img_Win.Draw_Data(Sender);

//    AT_QueueBuffer(Hndl, AlignedBuffers[ImgNo mod NumberOfBuffers], BufferSize);

    Inc(ImgNo);
    SB.SimpleText := ' FS : '+kk.ToString+', Expose : '+ (timeGetTime - TimeStart).ToString;
    Application.ProcessMessages;

    if not(Go) then
    begin
//      Memo.Lines.Add('Stop: '+AT_Command(Hndl, 'AcquisitionStop').ToString);
//      AT_Flush(Hndl);
      ShowMessage('Aborted');
      exit;
    end;
  end;

  for j:=0 to PH-1 do
    for i:=0 to PW-1 do
    begin
      Re := 0;
      Im := 0;

      for kk:=0 to PN-1do
      begin
        Im := Im + FSData[kk,j,i]*MySin[kk];
        Re := Re + FSData[kk,j,i]*MyCos[kk];
      end;
      PHData[j,i] := ArcTan2(Im,Re);
      //Amp[j,i] := Sqrt(Sqr(Im)+Sqr(Re)));
      Img_Win.PData[j,i] := PHData[j,i];
    end;
  Img_Win.Edit_PMin.Text := '-3.14';
  Img_Win.Edit_PMax.Text :=  '3.14';

  Img_Win.Draw_Data(Sender);
end;

procedure TForm_CT.BB_SaveClick(Sender: TObject);
begin
  if SaveDialog1.Execute then
  begin
    Img_Win.Save_Data(SaveDialog1.FileName,Sender);
  end;
end;

procedure TForm_CT.BB_SavePhClick(Sender: TObject);
var
  i,j,k : longint;
  FS : TFileStream;
  lData : array[0..4100] of WORD;
begin
  if SaveDialog1.Execute then
  begin
    Img_Win.Save_Data(SaveDialog1.FileName+'.ph',Sender);

    FS := TfileStream.Create(SaveDialog1.FileName,fmCreate);
    for k:=0 to StrToInt(Edit_FS_n.Text)-1 do
      for j:=0 to PH-1 do
      begin
        for i:=0 to PW-1 do
           lData[i] := FSData[k,j,i];
        FS.WriteBuffer(lData,PW*2);
      end;
    FS.Free;
  end;
end;

end.
